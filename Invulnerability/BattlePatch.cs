#define BETA
using System;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using HarmonyLib;
using TaleWorlds.MountAndBlade;
using TaleWorlds.Library;
using TaleWorlds.Engine;
using TaleWorlds.Core;
using System.Runtime.CompilerServices;
using NetworkMessages.FromServer;
using System.Collections.Concurrent;

#if BETA
namespace Invulnerability
{
    [HarmonyPatch(typeof(Agent), "HandleBlow")]
    class Patch01
    {
        static bool Prefix(Agent __instance, ref Blow b)
        {
            if (InvulnerableSettings.Instance.Enabled == false) return true;
            if (__instance.IsMainAgent)
            {
                if (!b.BlowFlag.HasAnyFlag(BlowFlags.NoSound))
                {
                    Agent agent = (b.OwnerId != -1) ? __instance.Mission.FindAgentWithIndex(b.OwnerId) : __instance;
                 
                    int soundIndex = GetSoundIndex(GetWeaponClass(ref b));
                    float forceParameter = GetForceParameter(ref b);
                    SoundEventParameter soundEventParameter = new SoundEventParameter("Force", forceParameter);
                    Mission.Current.MakeSound(soundIndex, b.Position, true, false, -1, -1, ref soundEventParameter);
                    MatrixFrame f = __instance.Frame;
                    Vec3 dirDist = b.Position - f.origin;
                    Vec3 dir = dirDist.NormalizedCopy();
                    float offset = 0.05f * agent.GetEyeGlobalHeight();
                    f.origin = b.Position + dir * offset;
                    Mission.Current.Scene.CreateBurstParticle(ParticleSystemManager.GetRuntimeIdByName("psys_game_metal_metal_coll"), f);
                    __instance.Mission.AddSoundAlarmFactorToAgents(b.OwnerId, b.Position, 15f);
                }
                return false;
            }
            return true;
        }

        private static WeaponClass GetWeaponClass(ref Blow b)
        {
            return b.WeaponRecord.WeaponClass;
        }

        private static int GetSoundIndex(WeaponClass weaponClass)
        {
            int num5 = -1;
            string str = "";
            bool flag = false;
            switch (weaponClass)
            {
                case WeaponClass.Dagger:
                case WeaponClass.ThrowingAxe:
                case WeaponClass.ThrowingKnife:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsDaggerlikeStone;
                    str = "SoundCodePhysicsDaggerlikeStone";
                    break;
                case WeaponClass.OneHandedSword:
                case WeaponClass.OneHandedAxe:
                case WeaponClass.Mace:
                case WeaponClass.Javelin:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsSwordlikeStone;
                    str = "SoundCodePhysicsSwordlikeStone";
                    break;
                case WeaponClass.TwoHandedSword:
                case WeaponClass.TwoHandedAxe:
                case WeaponClass.TwoHandedMace:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsGreatswordlikeStone;
                    str = "SoundCodePhysicsGreatswordlikeStone";
                    break;
                case WeaponClass.OneHandedPolearm:
                case WeaponClass.TwoHandedPolearm:
                case WeaponClass.LowGripPolearm:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsSpearlikeStone;
                    str = "SoundCodePhysicsSpearlikeStone";
                    break;
                case WeaponClass.Arrow:
                case WeaponClass.Bolt:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsArrowlikeStone;
                    str = "SoundCodePhysicsArrowlikeStone";
                    break;
                case WeaponClass.Bow:
                case WeaponClass.Crossbow:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsBowlikeStone;
                    str = "SoundCodePhysicsBowlikeStone";
                    break;
                case WeaponClass.Stone:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsSpearlikeStone;
                    str = "SoundCodePhysicsSpearlikeStone";
                    break;
                case WeaponClass.Boulder:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsBoulderStone;
                    str = "SoundCodePhysicsBoulderStone";
                    flag = true;
                    break;
                case WeaponClass.SmallShield:
                case WeaponClass.LargeShield:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsShieldlikeStone;
                    str = "SoundCodePhysicsShieldlikeStone";
                    break;
            }
            return num5;
        }

        private static float GetForceParameter(ref Blow b)
        {
            float res = 1f;
            return res;
        }

        private static float GetSoundParameterForArmorType(ArmorMaterialTypes armorMaterialType)
        {
            return (float)armorMaterialType * 0.1f;
        }

        public enum ArmorMaterialTypes : sbyte
        {
            None,
            Cloth,
            Leather,
            Chainmail,
            Plate
        }
    }

    [HarmonyPatch(typeof(Mission), "MeleeHitCallback")]
    class Patch02
    {
        static void Postfix(ref AttackCollisionData collisionData, Agent attacker, Agent victim,
            GameEntity realHitEntity, ref float inOutMomentumRemaining,
            ref MeleeCollisionReaction colReaction, CrushThroughState crushThroughState, Vec3 blowDir, Vec3 swingDir,
            ref object hitParticleResultData, bool crushedThroughWithoutAgentCollision)
        {
            if (InvulnerableSettings.Instance.Enabled == false) return;
            if (victim == Agent.Main)
            {
                // DecideWeaponCollisionReaction
                colReaction = MeleeCollisionReaction.Bounced;

            }
        }
    }

    [HarmonyPatch(typeof(Mission), "MissileHitCallback")]
    class Patch03
    {
        static bool Prefix(Mission __instance, ref bool __result, out int hitParticleIndex, ref AttackCollisionData collisionData, 
            Vec3 missileStartingPosition, Vec3 missilePosition, Vec3 missileAngularVelocity, Vec3 movementVelocity, 
            MatrixFrame attachGlobalFrame, MatrixFrame affectedShieldGlobalFrame, int numDamagedAgents, Agent attacker, Agent victim, 
            GameEntity hitEntity)
        {
            hitParticleIndex = -1;
            if (InvulnerableSettings.Instance.Enabled == false) return true;
            if (victim == Agent.Main)
            {
                FieldInfo missileField = AccessTools.Field(typeof(Mission), "_missiles");
                var missiles = (Dictionary<int, Mission.Missile>)missileField.GetValue(__instance);
                Mission.Missile missile = missiles[collisionData.AffectorWeaponSlotOrMissileIndex];
			    MissionWeapon weapon = missile.Weapon;
                WeaponFlags weaponFlags = missile.Weapon.CurrentUsageItem.WeaponFlags;
                float num = 1f;
                WeaponComponentData weaponComponentData = null;
                if (collisionData.AttackBlockedWithShield && weaponFlags.HasAnyFlag(WeaponFlags.CanPenetrateShield))
                {
                    return true;    // Use original code
                }
                hitParticleIndex = -1;
                Mission.MissileCollisionReaction missileCollisionReaction = Mission.MissileCollisionReaction.BounceBack;
                bool flag = !GameNetwork.IsSessionActive;
                bool missileHasPhysics = collisionData.MissileHasPhysics;
                PhysicsMaterial fromIndex = PhysicsMaterial.GetFromIndex(collisionData.PhysicsMaterialIndex);
                object obj = fromIndex.IsValid ? fromIndex.GetFlags() : PhysicsMaterialFlags.None;
                bool flag2 = (weaponFlags & WeaponFlags.AmmoSticksWhenShot) > (WeaponFlags)0UL;
                object obj2 = obj;
                bool flag5 = false;
                if (collisionData.MissileGoneUnderWater)
                {
                    return true;
                }
                else if (collisionData.AttackBlockedWithShield)
                {
                    return true;
                }
                else
                {
                    // Friendly control
                    if (attacker != null && attacker.IsFriendOf(victim))
                    {
                        if (!missileHasPhysics)
                        {
                            if (flag)
                            {
                                if (attacker.Controller == Agent.ControllerType.AI)
                                {
                                    flag5 = true;
                                }
                            }
                            else if ((MultiplayerOptions.OptionType.FriendlyFireDamageRangedFriendPercent.GetIntValue(MultiplayerOptions.MultiplayerOptionsAccessMode.CurrentMapOptions) <= 0 && MultiplayerOptions.OptionType.FriendlyFireDamageRangedSelfPercent.GetIntValue(MultiplayerOptions.MultiplayerOptionsAccessMode.CurrentMapOptions) <= 0) || __instance.Mode == MissionMode.Duel)
                            {
                                flag5 = true;
                            }
                        }
                    }
                    else if (victim.IsHuman && !attacker.IsEnemyOf(victim))
                    {
                        flag5 = true;
                    }
                    else if (flag && attacker != null && attacker.Controller == Agent.ControllerType.AI && victim.RiderAgent != null && attacker.IsFriendOf(victim.RiderAgent))
                    {
                        flag5 = true;
                    }

                    if (flag5)
                    {
                        missileCollisionReaction = Mission.MissileCollisionReaction.BecomeInvisible;
                    }
                    else
                    {
                        // even weapons with multiple penetration can't penetrate me.
                        //bool flag6 = (weaponFlags & WeaponFlags.MultiplePenetration) > (WeaponFlags)0UL;
                        //if (flag6)
                        //{
                        //    return true;    // Use original code
                        //}

                        MethodInfo getAttackCollisionResultsMethod = typeof(Mission).GetMethod("GetAttackCollisionResults", BindingFlags.NonPublic | BindingFlags.Instance);
                        getAttackCollisionResultsMethod.Invoke(__instance, new object[] {
                            attacker, victim, null, num, collisionData, weapon, false, false, false,  weaponComponentData
                        });
                        Blow blow = CreateMissileBlow(attacker, collisionData, weapon, missilePosition, missileStartingPosition);
                        blow.BlowFlag |= BlowFlags.ShrugOff;    // Any attack is so neglectable to our hero
                        if (victim.State == AgentState.Active)
                        {
                            MethodInfo registerBlowMethod = AccessTools.Method("Mission:RegisterBlow");
                            registerBlowMethod.Invoke(__instance, new object[] { attacker, victim, null, blow, collisionData, weapon });
                            //__instance.RegisterBlow(attacker, victim, null, blow, ref collisionData);
                        }

                    }
                }
                MatrixFrame attachLocalFrame;
                attachLocalFrame = attachGlobalFrame;


                // Any missile bounces back
                WeaponFlags weaponFlags2 = weaponFlags & WeaponFlags.AmmoBreakOnBounceBackMask;
                Vec3 zero = Vec3.Zero;
                Vec3 zero2 = Vec3.Zero;
                if ((weaponFlags2 == WeaponFlags.AmmoCanBreakOnBounceBack && 
                    collisionData.MissileVelocity.Length > 
                    ManagedParameters.Instance.GetManagedParameter(ManagedParametersEnum.BreakableProjectileMinimumBreakSpeed)) || 
                    weaponFlags2 == WeaponFlags.AmmoBreaksOnBounceBack)
                {

                    if(collisionData.MissileTotalDamage > InvulnerableSettings.Instance.ArrowBreakingThres)
                    {
                        missileCollisionReaction = Mission.MissileCollisionReaction.BecomeInvisible;
                        Mission.Current.Scene.CreateBurstParticle(ParticleSystemManager.GetRuntimeIdByName("psys_game_broken_arrow"), attachLocalFrame);
                    }
                    else
                    {
                        hitParticleIndex = ParticleSystemManager.GetRuntimeIdByName("psys_game_broken_arrow");  // For some reason, setting this doesn't work
                    }

                }
                else
                {
                    missile.CalculateBounceBackVelocity(missileAngularVelocity, collisionData, out zero, out zero2);
                    Mission.Current.Scene.CreateBurstParticle(ParticleSystemManager.GetRuntimeIdByName("psys_game_missile_metal_coll"), attachLocalFrame);
                }
                __instance.HandleMissileCollisionReaction(collisionData.AffectorWeaponSlotOrMissileIndex, missileCollisionReaction, attachLocalFrame,
                    attacker, null, collisionData.AttackBlockedWithShield, collisionData.CollisionBoneIndex, null, zero, zero2, -1);
                foreach (MissionBehaviour missionBehaviour in __instance.MissionBehaviours)
                {
                    missionBehaviour.OnMissileHit(attacker, null, flag5);
                }

                __result = true;
                return false;
            }
            return true;
        }


        static private Blow CreateMissileBlow(Agent attackerAgent, in AttackCollisionData collisionData, in MissionWeapon attackerWeapon, Vec3 missilePosition, Vec3 missileStartingPosition)
        {
            Blow blow = new Blow(attackerAgent.Index);
            MissionWeapon missionWeapon = attackerWeapon;
            blow.BlowFlag = (missionWeapon.CurrentUsageItem.WeaponFlags.HasAnyFlag(WeaponFlags.CanKnockDown) ? BlowFlags.KnockBack : BlowFlags.None);
            AttackCollisionData attackCollisionData = collisionData;
            blow.Direction = attackCollisionData.MissileVelocity.NormalizedCopy();
            blow.SwingDirection = blow.Direction;
            attackCollisionData = collisionData;
            blow.Position = attackCollisionData.CollisionGlobalPosition;
            attackCollisionData = collisionData;
            blow.BoneIndex = attackCollisionData.CollisionBoneIndex;
            attackCollisionData = collisionData;
            blow.StrikeType = (StrikeType)attackCollisionData.StrikeType;
            attackCollisionData = collisionData;
            blow.DamageType = (DamageTypes)attackCollisionData.DamageType;
            attackCollisionData = collisionData;
            blow.VictimBodyPart = attackCollisionData.VictimHitBodyPart;
            missionWeapon = attackerWeapon;
            ItemObject item = missionWeapon.Item;
            missionWeapon = attackerWeapon;
            WeaponComponentData currentUsageItem = missionWeapon.CurrentUsageItem;
            attackCollisionData = collisionData;
            int affectorWeaponSlotOrMissileIndex = attackCollisionData.AffectorWeaponSlotOrMissileIndex;
            Monster monster = attackerAgent.Monster;
            missionWeapon = attackerWeapon;
            sbyte boneToAttachForItemFlags = monster.GetBoneToAttachForItemFlags(missionWeapon.Item.ItemFlags);
            attackCollisionData = collisionData;
            blow.WeaponRecord.FillAsMissileBlow(item, currentUsageItem, affectorWeaponSlotOrMissileIndex, boneToAttachForItemFlags, missileStartingPosition, missilePosition, attackCollisionData.MissileVelocity);
            blow.BaseMagnitude = collisionData.BaseMagnitude;
            blow.MovementSpeedDamageModifier = collisionData.MovementSpeedDamageModifier;
            blow.AbsorbedByArmor = (float)collisionData.AbsorbedByArmor;
            blow.InflictedDamage = collisionData.InflictedDamage;
            blow.SelfInflictedDamage = collisionData.SelfInflictedDamage;
            blow.DamageCalculated = true;
            return blow;
        }


    }

    [HarmonyPatch(typeof(Mission), "DecideAgentHitParticles")]
    class Patch04
    {
        static void Prefix(Blow blow, Agent victim, ref AttackCollisionData collisionData, ref object hprd)
        {
            if (InvulnerableSettings.Instance.Enabled == false) return;
            if (victim == Agent.Main)
            {
                blow.WeaponRecord.WeaponFlags |= WeaponFlags.NoBlood; // Then going into the original will not render blood.
            }
        }
    }

    [HarmonyPatch(typeof(Mission), "AddCombatLogSafe")]
    class Patch06
    {
        static bool Prefix(Mission __instance, Agent attackerAgent, Agent victimAgent, GameEntity hitEntity, CombatLogData combatLog)
        {
            if (InvulnerableSettings.Instance.Enabled == false) return true;
            if (victimAgent != Agent.Main)
                return true;

            //if (Config.PRINT_HURT)
            if(InvulnerableSettings.Instance.PrintHurt)
                return true;
            return false;
        }
    }

}
#else
namespace Invulnerability
{
    [HarmonyPatch(typeof(Agent), "HandleBlow")]
    class Patch01
    {
        static bool Prefix(Agent __instance, ref Blow b)
        {
            if (InvulnerableSettings.Instance.Enabled == false) return true;
            if (__instance.IsMainAgent)
            {
                if (!b.BlowFlag.HasAnyFlag(BlowFlags.NoSound))
                {
                    Agent agent = (b.OwnerId != -1) ? __instance.Mission.FindAgentWithIndex(b.OwnerId) : __instance;
                 
                    int soundIndex = GetSoundIndex(GetWeaponClass(ref b));
                    float forceParameter = GetForceParameter(ref b);
                    SoundEventParameter soundEventParameter = new SoundEventParameter("Force", forceParameter);
                    Mission.Current.MakeSound(soundIndex, b.Position, true, false, -1, -1, ref soundEventParameter);
                    MatrixFrame f = __instance.Frame;
                    Vec3 dirDist = b.Position - f.origin;
                    Vec3 dir = dirDist.NormalizedCopy();
                    float offset = 0.05f * agent.GetEyeGlobalHeight();
                    f.origin = b.Position + dir * offset;
                    Mission.Current.Scene.CreateBurstParticle(ParticleSystemManager.GetRuntimeIdByName("psys_game_metal_metal_coll"), f);
                    __instance.Mission.AddSoundAlarmFactorToAgents(b.OwnerId, b.Position, 15f);
                }
                return false;
            }
            return true;
        }

        private static WeaponClass GetWeaponClass(ref Blow b)
        {
            return b.WeaponRecord.WeaponClass;
        }

        private static int GetSoundIndex(WeaponClass weaponClass)
        {
            int num5 = -1;
            string str = "";
            bool flag = false;
            switch (weaponClass)
            {
                case WeaponClass.Dagger:
                case WeaponClass.ThrowingAxe:
                case WeaponClass.ThrowingKnife:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsDaggerlikeStone;
                    str = "SoundCodePhysicsDaggerlikeStone";
                    break;
                case WeaponClass.OneHandedSword:
                case WeaponClass.OneHandedAxe:
                case WeaponClass.Mace:
                case WeaponClass.Javelin:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsSwordlikeStone;
                    str = "SoundCodePhysicsSwordlikeStone";
                    break;
                case WeaponClass.TwoHandedSword:
                case WeaponClass.TwoHandedAxe:
                case WeaponClass.TwoHandedMace:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsGreatswordlikeStone;
                    str = "SoundCodePhysicsGreatswordlikeStone";
                    break;
                case WeaponClass.OneHandedPolearm:
                case WeaponClass.TwoHandedPolearm:
                case WeaponClass.LowGripPolearm:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsSpearlikeStone;
                    str = "SoundCodePhysicsSpearlikeStone";
                    break;
                case WeaponClass.Arrow:
                case WeaponClass.Bolt:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsArrowlikeStone;
                    str = "SoundCodePhysicsArrowlikeStone";
                    break;
                case WeaponClass.Bow:
                case WeaponClass.Crossbow:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsBowlikeStone;
                    str = "SoundCodePhysicsBowlikeStone";
                    break;
                case WeaponClass.Stone:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsSpearlikeStone;
                    str = "SoundCodePhysicsSpearlikeStone";
                    break;
                case WeaponClass.Boulder:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsBoulderStone;
                    str = "SoundCodePhysicsBoulderStone";
                    flag = true;
                    break;
                case WeaponClass.SmallShield:
                case WeaponClass.LargeShield:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsShieldlikeStone;
                    str = "SoundCodePhysicsShieldlikeStone";
                    break;
            }
            return num5;
        }

        private static float GetForceParameter(ref Blow b)
        {
            float res = 1f;
            return res;
        }

        private static float GetSoundParameterForArmorType(ArmorMaterialTypes armorMaterialType)
        {
            return (float)armorMaterialType * 0.1f;
        }

        public enum ArmorMaterialTypes : sbyte
        {
            None,
            Cloth,
            Leather,
            Chainmail,
            Plate
        }
    }

    [HarmonyPatch(typeof(Mission), "MeleeHitCallback")]
    class Patch02
    {
        static void Postfix(ref AttackCollisionData collisionData, Agent attacker, Agent victim, 
            GameEntity realHitEntity, float momentumRemainingToComputeDamage, 
            ref float inOutMomentumRemaining, ref MeleeCollisionReaction colReaction, 
            CrushThroughState crushThroughState, Vec3 blowDir, Vec3 swingDir, 
            ref object hitParticleResultData, bool crushedThroughWithoutAgentCollision)
        {
            if (InvulnerableSettings.Instance.Enabled == false) return;
            if (victim == Agent.Main)
            {
                // DecideWeaponCollisionReaction
                colReaction = MeleeCollisionReaction.Bounced;

            }
        }
    }


    [HarmonyPatch(typeof(Mission), "MissileHitCallback")]
    class Patch03
    {
        static bool Prefix(Mission __instance, ref bool __result, out int hitParticleIndex, ref AttackCollisionData collisionData, 
            Vec3 missileStartingPosition, Vec3 missilePosition, Vec3 missileAngularVelocity, Vec3 movementVelocity, 
            MatrixFrame attachGlobalFrame, MatrixFrame affectedShieldGlobalFrame, int numDamagedAgents, Agent attacker, Agent victim, 
            GameEntity hitEntity)
        {
            hitParticleIndex = -1;
            if (InvulnerableSettings.Instance.Enabled == false) return true;
            if (victim == Agent.Main)
            {
                FieldInfo missileField = AccessTools.Field(typeof(Mission), "_missiles");
                var missiles = (Dictionary<int, Mission.Missile>)missileField.GetValue(__instance);
                Mission.Missile missile = missiles[collisionData.AffectorWeaponSlotOrMissileIndex];
			    MissionWeapon weapon = missile.Weapon;
                WeaponFlags weaponFlags = missile.Weapon.CurrentUsageItem.WeaponFlags;
                float num = 1f;
                WeaponComponentData weaponComponentData = null;
                if (collisionData.AttackBlockedWithShield && weaponFlags.HasAnyFlag(WeaponFlags.CanPenetrateShield))
                {
                    return true;    // Use original code
                }
                hitParticleIndex = -1;
                Mission.MissileCollisionReaction missileCollisionReaction = Mission.MissileCollisionReaction.BounceBack;
                bool flag = !GameNetwork.IsSessionActive;
                bool missileHasPhysics = collisionData.MissileHasPhysics;
                PhysicsMaterial fromIndex = PhysicsMaterial.GetFromIndex(collisionData.PhysicsMaterialIndex);
                object obj = fromIndex.IsValid ? fromIndex.GetFlags() : PhysicsMaterialFlags.None;
                bool flag2 = (weaponFlags & WeaponFlags.AmmoSticksWhenShot) > (WeaponFlags)0UL;
                object obj2 = obj;
                bool flag5 = false;
                if (collisionData.MissileGoneUnderWater)
                {
                    return true;
                }
                else if (collisionData.AttackBlockedWithShield)
                {
                    return true;
                }
                else
                {
                    // Friendly control
                    if (attacker != null && attacker.IsFriendOf(victim))
                    {
                        if (!missileHasPhysics)
                        {
                            if (flag)
                            {
                                if (attacker.Controller == Agent.ControllerType.AI)
                                {
                                    flag5 = true;
                                }
                            }
                            else if ((MultiplayerOptions.OptionType.FriendlyFireDamageRangedFriendPercent.GetIntValue(MultiplayerOptions.MultiplayerOptionsAccessMode.CurrentMapOptions) <= 0 && MultiplayerOptions.OptionType.FriendlyFireDamageRangedSelfPercent.GetIntValue(MultiplayerOptions.MultiplayerOptionsAccessMode.CurrentMapOptions) <= 0) || __instance.Mode == MissionMode.Duel)
                            {
                                flag5 = true;
                            }
                        }
                    }
                    else if (victim.IsHuman && !attacker.IsEnemyOf(victim))
                    {
                        flag5 = true;
                    }
                    else if (flag && attacker != null && attacker.Controller == Agent.ControllerType.AI && victim.RiderAgent != null && attacker.IsFriendOf(victim.RiderAgent))
                    {
                        flag5 = true;
                    }

                    if (flag5)
                    {
                        missileCollisionReaction = Mission.MissileCollisionReaction.BecomeInvisible;
                    }
                    else
                    {
                        // even weapons with multiple penetration can't penetrate me.
                        //bool flag6 = (weaponFlags & WeaponFlags.MultiplePenetration) > (WeaponFlags)0UL;
                        //if (flag6)
                        //{
                        //    return true;    // Use original code
                        //}

                        MethodInfo getAttackCollisionResultsMethod = typeof(Mission).GetMethod("GetAttackCollisionResults", BindingFlags.NonPublic | BindingFlags.Instance);
                        getAttackCollisionResultsMethod.Invoke(__instance, new object[] {
                            attacker, victim, null, num, collisionData, weapon, false, false, false,  weaponComponentData
                        });
                        Blow blow = CreateMissileBlow(attacker, collisionData, weapon, missilePosition, missileStartingPosition);
                        blow.BlowFlag |= BlowFlags.ShrugOff;    // Any attack is so neglectable to our hero
                        if (victim.State == AgentState.Active)
                        {
                            MethodInfo registerBlowMethod = AccessTools.Method("Mission:RegisterBlow");
                            registerBlowMethod.Invoke(__instance, new object[] { attacker, victim, null, blow, collisionData, weapon });
                            //__instance.RegisterBlow(attacker, victim, null, blow, ref collisionData);
                        }

                    }
                }
                MatrixFrame attachLocalFrame;
                attachLocalFrame = attachGlobalFrame;


                // Any missile bounces back
                WeaponFlags weaponFlags2 = weaponFlags & WeaponFlags.AmmoBreakOnBounceBackMask;
                Vec3 zero = Vec3.Zero;
                Vec3 zero2 = Vec3.Zero;
                if ((weaponFlags2 == WeaponFlags.AmmoCanBreakOnBounceBack && 
                    collisionData.MissileVelocity.Length > 
                    ManagedParameters.Instance.GetManagedParameter(ManagedParametersEnum.BreakableProjectileMinimumBreakSpeed)) || 
                    weaponFlags2 == WeaponFlags.AmmoBreaksOnBounceBack)
                {

                    if(collisionData.MissileTotalDamage > InvulnerableSettings.Instance.ArrowBreakingThres)
                    {
                        missileCollisionReaction = Mission.MissileCollisionReaction.BecomeInvisible;
                        Mission.Current.Scene.CreateBurstParticle(ParticleSystemManager.GetRuntimeIdByName("psys_game_broken_arrow"), attachLocalFrame);
                    }
                    else
                    {
                        hitParticleIndex = ParticleSystemManager.GetRuntimeIdByName("psys_game_broken_arrow");  // For some reason, setting this doesn't work
                    }

                }
                else
                {
                    missile.CalculateBounceBackVelocity(missileAngularVelocity, collisionData, out zero, out zero2);
                    Mission.Current.Scene.CreateBurstParticle(ParticleSystemManager.GetRuntimeIdByName("psys_game_missile_metal_coll"), attachLocalFrame);
                }
                __instance.HandleMissileCollisionReaction(collisionData.AffectorWeaponSlotOrMissileIndex, missileCollisionReaction, attachLocalFrame,
                    attacker, null, collisionData.AttackBlockedWithShield, collisionData.CollisionBoneIndex, null, zero, zero2, -1);
                foreach (MissionBehaviour missionBehaviour in __instance.MissionBehaviours)
                {
                    missionBehaviour.OnMissileHit(attacker, null, flag5);
                }

                __result = true;
                return false;
            }
            return true;
        }


        static private Blow CreateMissileBlow(Agent attackerAgent, in AttackCollisionData collisionData, in MissionWeapon attackerWeapon, Vec3 missilePosition, Vec3 missileStartingPosition)
        {
            Blow blow = new Blow(attackerAgent.Index);
            MissionWeapon missionWeapon = attackerWeapon;
            blow.BlowFlag = (missionWeapon.CurrentUsageItem.WeaponFlags.HasAnyFlag(WeaponFlags.CanKnockDown) ? BlowFlags.KnockBack : BlowFlags.None);
            AttackCollisionData attackCollisionData = collisionData;
            blow.Direction = attackCollisionData.MissileVelocity.NormalizedCopy();
            blow.SwingDirection = blow.Direction;
            attackCollisionData = collisionData;
            blow.Position = attackCollisionData.CollisionGlobalPosition;
            attackCollisionData = collisionData;
            blow.BoneIndex = attackCollisionData.CollisionBoneIndex;
            attackCollisionData = collisionData;
            blow.StrikeType = (StrikeType)attackCollisionData.StrikeType;
            attackCollisionData = collisionData;
            blow.DamageType = (DamageTypes)attackCollisionData.DamageType;
            attackCollisionData = collisionData;
            blow.VictimBodyPart = attackCollisionData.VictimHitBodyPart;
            missionWeapon = attackerWeapon;
            ItemObject item = missionWeapon.Item;
            missionWeapon = attackerWeapon;
            WeaponComponentData currentUsageItem = missionWeapon.CurrentUsageItem;
            attackCollisionData = collisionData;
            int affectorWeaponSlotOrMissileIndex = attackCollisionData.AffectorWeaponSlotOrMissileIndex;
            Monster monster = attackerAgent.Monster;
            missionWeapon = attackerWeapon;
            sbyte boneToAttachForItemFlags = monster.GetBoneToAttachForItemFlags(missionWeapon.Item.ItemFlags);
            attackCollisionData = collisionData;
            blow.WeaponRecord.FillAsMissileBlow(item, currentUsageItem, affectorWeaponSlotOrMissileIndex, boneToAttachForItemFlags, missileStartingPosition, missilePosition, attackCollisionData.MissileVelocity);
            blow.BaseMagnitude = collisionData.BaseMagnitude;
            blow.MovementSpeedDamageModifier = collisionData.MovementSpeedDamageModifier;
            blow.AbsorbedByArmor = (float)collisionData.AbsorbedByArmor;
            blow.InflictedDamage = collisionData.InflictedDamage;
            blow.SelfInflictedDamage = collisionData.SelfInflictedDamage;
            blow.DamageCalculated = true;
            return blow;
        }


    }

    [HarmonyPatch(typeof(Mission), "DecideAgentHitParticles")]
    class Patch04
    {
        static void Prefix(Agent victim, ref Blow blow, ref object hprd)
        {
            if (InvulnerableSettings.Instance.Enabled == false) return;
            if (victim == Agent.Main)
            {
                blow.WeaponRecord.WeaponFlags |= WeaponFlags.NoBlood; // Then going into the original will not render blood.
            }
        }
    }

    [HarmonyPatch(typeof(Mission), "AddCombatLogSafe")]
    class Patch06
    {
        static bool Prefix(Mission __instance, Agent attackerAgent, Agent victimAgent, GameEntity hitEntity, CombatLogData combatLog)
        {
            if (InvulnerableSettings.Instance.Enabled == false) return true;
            if (victimAgent != Agent.Main)
                return true;

            //if (Config.PRINT_HURT)
            if(InvulnerableSettings.Instance.PrintHurt)
                return true;
            return false;
        }
    }

}
#endif