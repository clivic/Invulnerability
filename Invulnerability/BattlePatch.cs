using System;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using HarmonyLib;
using TaleWorlds.MountAndBlade;
using TaleWorlds.Library;
using TaleWorlds.Engine;
using TaleWorlds.Core;
using System.Runtime.CompilerServices;
using NetworkMessages.FromServer;
using System.Collections.Concurrent;

namespace Invulnerability
{
    [HarmonyPatch(typeof(Agent), "HandleBlow")]
    class Patch01
    {
        static bool Prefix(Agent __instance, ref Blow b)
        {

            if (__instance.IsMainAgent)
            {
                if (!b.BlowFlag.HasAnyFlag(BlowFlags.NoSound))
                {
                    Agent agent = (b.OwnerId != -1) ? __instance.Mission.FindAgentWithIndex(b.OwnerId) : __instance;
                    //bool isCritBlow = b.IsBlowCrit(__instance.Monster.HitPoints * 4);
                    //bool isLowBlow = b.IsBlowLow(__instance.Monster.HitPoints);
                    //bool isOwnerHumanoid = agent != null && agent.IsHuman;
                    //bool isNonTipThrust = b.BlowFlag.HasAnyFlag(BlowFlags.NonTipThrust);
                    //int hitSound = b.WeaponRecord.GetHitSound(isOwnerHumanoid, isCritBlow, isLowBlow, isNonTipThrust, b.AttackType, b.DamageType);
                    //int hitSound = RandomSound();
                    //float soundParameterForArmorType = GetSoundParameterForArmorType(ArmorMaterialTypes.Plate);
                    //__instance.Mission.MakeSound(hitSound, b.Position, false, true, b.OwnerId, __instance.Index, ref soundEventParameter);

                    //b.BlowFlag |= BlowFlags.ShrugOff;
                    int soundIndex = GetSoundIndex(GetWeaponClass(ref b));
                    float forceParameter = GetForceParameter(ref b);
                    SoundEventParameter soundEventParameter = new SoundEventParameter("Force", forceParameter);
                    Mission.Current.MakeSound(soundIndex, b.Position, true, false, -1, -1, ref soundEventParameter);
                    MatrixFrame f = __instance.Frame;
                    Vec3 dirDist = b.Position - f.origin;
                    Vec3 dir = dirDist.NormalizedCopy();
                    float offset = 0.05f * agent.GetEyeGlobalHeight();
                    f.origin = b.Position + dir * offset;
                    Mission.Current.Scene.CreateBurstParticle(ParticleSystemManager.GetRuntimeIdByName("psys_game_metal_metal_coll"), f);
                    __instance.Mission.AddSoundAlarmFactorToAgents(b.OwnerId, b.Position, 15f);
                }
                return false;
            }
            return true;
        }

        private static WeaponClass GetWeaponClass(ref Blow b)
        {
            return b.WeaponRecord.ItmClass;
        }

        private static int GetSoundIndex(WeaponClass weaponClass)
        {
            int num5 = -1;
            string str = "";
            bool flag = false;
            switch (weaponClass)
            {
                case WeaponClass.Dagger:
                case WeaponClass.ThrowingAxe:
                case WeaponClass.ThrowingKnife:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsDaggerlikeStone;
                    str = "SoundCodePhysicsDaggerlikeStone";
                    break;
                case WeaponClass.OneHandedSword:
                case WeaponClass.OneHandedAxe:
                case WeaponClass.Mace:
                case WeaponClass.Javelin:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsSwordlikeStone;
                    str = "SoundCodePhysicsSwordlikeStone";
                    break;
                case WeaponClass.TwoHandedSword:
                case WeaponClass.TwoHandedAxe:
                case WeaponClass.TwoHandedMace:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsGreatswordlikeStone;
                    str = "SoundCodePhysicsGreatswordlikeStone";
                    break;
                case WeaponClass.OneHandedPolearm:
                case WeaponClass.TwoHandedPolearm:
                case WeaponClass.LowGripPolearm:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsSpearlikeStone;
                    str = "SoundCodePhysicsSpearlikeStone";
                    break;
                case WeaponClass.Arrow:
                case WeaponClass.Bolt:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsArrowlikeStone;
                    str = "SoundCodePhysicsArrowlikeStone";
                    break;
                case WeaponClass.Bow:
                case WeaponClass.Crossbow:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsBowlikeStone;
                    str = "SoundCodePhysicsBowlikeStone";
                    break;
                case WeaponClass.Stone:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsSpearlikeStone;
                    str = "SoundCodePhysicsSpearlikeStone";
                    break;
                case WeaponClass.Boulder:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsBoulderStone;
                    str = "SoundCodePhysicsBoulderStone";
                    flag = true;
                    break;
                case WeaponClass.SmallShield:
                case WeaponClass.LargeShield:
                    num5 = ItemPhysicsSoundContainer.SoundCodePhysicsShieldlikeStone;
                    str = "SoundCodePhysicsShieldlikeStone";
                    break;
            }
            //Helper.ShowAndLog($"Playing sound {str}", new Color(0, .5f, 0));
            return num5;
        }

        private static float GetForceParameter(ref Blow b)
        {
            float res = 1f;
            //var agentMain = Agent.Main;
            //if (agentMain != null)
            //{
            //    if (b.IsBlowLow(agentMain.Monster.HitPoints))
            //    {
            //        res = MBRandom.RandomFloatRanged(.4f);
            //    }
            //    else if (b.IsBlowCrit(agentMain.Monster.HitPoints))
            //    {
            //        res = MBRandom.RandomFloatRanged(.9f, 1f);
            //    }
            //    else
            //    {
            //        res = MBRandom.RandomFloatRanged(.4f, .9f);
            //    }
            //}
            return res;
        }

        private static float GetSoundParameterForArmorType(ArmorMaterialTypes armorMaterialType)
        {
            return (float)armorMaterialType * 0.1f;
        }

        public enum ArmorMaterialTypes : sbyte
        {
            None,
            Cloth,
            Leather,
            Chainmail,
            Plate
        }
    }

    [HarmonyPatch(typeof(Mission), "MeleeHitCallback")]
    class Patch02
    {
        static void Postfix(ref AttackCollisionData collisionData, Agent attacker, Agent victim,
            ref float inOutMomentumRemaining, ref MeleeCollisionReaction colReaction/*, ref dynamic hprd*/)
        {
            if (victim.IsMainAgent)
            {
                // DecideWeaponCollisionReaction
                colReaction = MeleeCollisionReaction.Bounced;

            }
        }
    }


    [HarmonyPatch(typeof(Mission), "MissileHitCallback")]
    class Patch03
    {
        static bool Prefix(Mission __instance, ref bool __result, out int hitParticleIndex, ref AttackCollisionData collisionData, int missileIndex,
            Vec3 missileStartingPosition, Vec3 missilePosition, Vec3 missileAngularVelocity, Vec3 movementVelocity,
            MatrixFrame attachGlobalFrame, MatrixFrame affectedShieldGlobalFrame,
            Agent attacker, Agent victim, GameEntity hitEntity)
        {
            hitParticleIndex = -1;
            if (victim == Agent.Main)
            {
                FieldInfo missileField = AccessTools.Field(typeof(Mission), "_missiles");
                var missiles = (Dictionary<int, Mission.Missile>)missileField.GetValue(__instance);
                Mission.Missile missile = missiles[missileIndex];
                WeaponFlags weaponFlags = missile.Weapon.CurrentUsageItem.WeaponFlags;
                float num = 1f;
                WeaponComponentData weaponComponentData = null;
                if (collisionData.AttackBlockedWithShield && weaponFlags.HasAnyFlag(WeaponFlags.CanPenetrateShield))
                {
                    return true;    // Use original code
                }
                hitParticleIndex = -1;
                Mission.MissileCollisionReaction missileCollisionReaction = Mission.MissileCollisionReaction.BounceBack;
                bool flag = !GameNetwork.IsSessionActive;
                bool missileHasPhysics = collisionData.MissileHasPhysics;
                PhysicsMaterial fromIndex = PhysicsMaterial.GetFromIndex(collisionData.PhysicsMaterialIndex);
                object obj = fromIndex.IsValid ? fromIndex.GetFlags() : PhysicsMaterialFlags.None;
                bool flag2 = (weaponFlags & WeaponFlags.AmmoSticksWhenShot) > (WeaponFlags)0UL;
                object obj2 = obj;
                bool flag5 = false;
                if (collisionData.MissileGoneUnderWater)
                {
                    return true;
                }
                else if (collisionData.AttackBlockedWithShield)
                {
                    return true;
                }
                else
                {
                    // Friendly control
                    if (attacker != null && attacker.IsFriendOf(victim))
                    {
                        if (!missileHasPhysics)
                        {
                            if (flag)
                            {
                                if (attacker.Controller == Agent.ControllerType.AI)
                                {
                                    flag5 = true;
                                }
                            }
                            else if ((MultiplayerOptions.OptionType.FriendlyFireDamageRangedFriendPercent.GetIntValue(MultiplayerOptions.MultiplayerOptionsAccessMode.CurrentMapOptions) <= 0 && MultiplayerOptions.OptionType.FriendlyFireDamageRangedSelfPercent.GetIntValue(MultiplayerOptions.MultiplayerOptionsAccessMode.CurrentMapOptions) <= 0) || __instance.Mode == MissionMode.Duel)
                            {
                                flag5 = true;
                            }
                        }
                    }
                    else if (victim.IsHuman && !attacker.IsEnemyOf(victim))
                    {
                        flag5 = true;
                    }
                    else if (flag && attacker != null && attacker.Controller == Agent.ControllerType.AI && victim.RiderAgent != null && attacker.IsFriendOf(victim.RiderAgent))
                    {
                        flag5 = true;
                    }

                    if (flag5)
                    {
                        missileCollisionReaction = Mission.MissileCollisionReaction.BecomeInvisible;
                    }
                    else
                    {
                        bool flag6 = (weaponFlags & WeaponFlags.MultiplePenetration) > (WeaponFlags)0UL;
                        if (flag6)
                        {
                            return true;    // Use original code
                        }

                        MethodInfo getAttackCollisionResultsMethod = typeof(Mission).GetMethod("GetAttackCollisionResults", BindingFlags.NonPublic | BindingFlags.Instance);
                        //    AccessTools.Method("Mission:GetAttackCollisionResults", new Type[]{
                        //    typeof(Agent),typeof(Agent), typeof(GameEntity) , typeof(float), typeof(AttackCollisionData),
                        //    typeof(bool) , typeof(bool) , typeof(WeaponComponentData) 
                        //});
                        getAttackCollisionResultsMethod.Invoke(__instance, new object[] {
                            attacker, victim, null, num, collisionData, false, false, weaponComponentData
                        });
                        Blow blow = CreateMissileBlow(attacker, ref collisionData, missile, missilePosition, missileStartingPosition);
                        blow.BlowFlag |= BlowFlags.ShrugOff;    // Any attack is so neglectable to our hero
                        if (victim.State == AgentState.Active)
                        {
                            MethodInfo registerBlowMethod = AccessTools.Method("Mission:RegisterBlow");
                            registerBlowMethod.Invoke(__instance, new object[] { attacker, victim, null, blow, collisionData });
                            //__instance.RegisterBlow(attacker, victim, null, blow, ref collisionData);
                        }

                    }
                }
                MatrixFrame attachLocalFrame;
                //if (!collisionData.MissileHasPhysics)
                //{
                //    bool shouldMissilePenetrate = missileCollisionReaction == Mission.MissileCollisionReaction.Stick;
                //    MethodInfo calculateAttachedLocalFrameMethod = AccessTools.Method("Mission:CalculateAttachedLocalFrame");
                //    attachLocalFrame = (MatrixFrame)calculateAttachedLocalFrameMethod.Invoke(__instance, new object[] {
                //        attachGlobalFrame, collisionData, missile.Weapon.CurrentUsageItem,
                //        victim, hitEntity, movementVelocity, missileAngularVelocity, affectedShieldGlobalFrame, shouldMissilePenetrate});
                //    //attachLocalFrame = __instance.CalculateAttachedLocalFrame(ref attachGlobalFrame, collisionData, missile.Weapon.CurrentUsageItem, victim, hitEntity, movementVelocity, missileAngularVelocity, affectedShieldGlobalFrame, shouldMissilePenetrate);
                //}
                //else
                {
                    attachLocalFrame = attachGlobalFrame;
                }


                // Any missile bounces back
                WeaponFlags weaponFlags2 = weaponFlags & WeaponFlags.AmmoBreakOnBounceBackMask;
                Vec3 zero = Vec3.Zero;
                Vec3 zero2 = Vec3.Zero;
                if ((weaponFlags2 == WeaponFlags.AmmoCanBreakOnBounceBack && collisionData.MissileVelocity.Length > ManagedParameters.Instance.GetManagedParameter(ManagedParametersEnum.BreakableProjectileMinimumBreakSpeed)) || weaponFlags2 == WeaponFlags.AmmoBreaksOnBounceBack)
                {
                    missileCollisionReaction = Mission.MissileCollisionReaction.BecomeInvisible;
                    hitParticleIndex = ParticleSystemManager.GetRuntimeIdByName("psys_game_broken_arrow");  // For some reason, setting this doesn't work
                    Mission.Current.Scene.CreateBurstParticle(ParticleSystemManager.GetRuntimeIdByName("psys_game_broken_arrow"), attachLocalFrame);
                }
                else
                {
                    missile.CalculateBounceBackVelocity(missileAngularVelocity, collisionData, out zero, out zero2);
                    Mission.Current.Scene.CreateBurstParticle(ParticleSystemManager.GetRuntimeIdByName("psys_game_missile_metal_coll"), attachLocalFrame);
                    //Helper.ShowAndLog($"zero: {zero}, zero2: {zero2}");
                }
                //Helper.ShowAndLog($"Final zero: {zero}, zero2: {zero2}");
                //missile.Entity.SetVisibilityExcludeParents(true);
                //MethodInfo calculateSpawnWeaponAsDropFromMissile = AccessTools.Method("Mission:SpawnWeaponAsDropFromMissile");
                //calculateSpawnWeaponAsDropFromMissile.Invoke(__instance, new object[] {
                //    missileIndex, null, attachLocalFrame, Mission.WeaponSpawnFlags.AsMissile | Mission.WeaponSpawnFlags.WithPhysics,
                //    zero, zero2, -1
                //});

                //__instance.SpawnWeaponAsDropFromMissile(missileIndex, null, ref attachLocalFrame, Mission.WeaponSpawnFlags.AsMissile | Mission.WeaponSpawnFlags.WithPhysics, ref bounceBackVelocity, ref bounceBackAngularVelocity, forcedSpawnIndex);
                __instance.HandleMissileCollisionReaction(missileIndex, missileCollisionReaction, attachLocalFrame,
                    attacker, null, false, collisionData.CollisionBoneIndex, null, zero, zero2, -1);
                foreach (MissionBehaviour missionBehaviour in __instance.MissionBehaviours)
                {
                    missionBehaviour.OnMissileHit(attacker, null, flag5);
                }

                __result = true;
                return false;
            }
            return true;
        }


        static Blow CreateMissileBlow(Agent attackerAgent, ref AttackCollisionData collisionData, Mission.Missile missile, Vec3 missilePosition, Vec3 missileStartingPosition)
        {
            Blow blow = new Blow(attackerAgent.Index);
            blow.BlowFlag = (missile.Weapon.CurrentUsageItem.WeaponFlags.HasAnyFlag(WeaponFlags.CanKnockDown) ? BlowFlags.KnockBack : BlowFlags.None);
            blow.Direction = collisionData.MissileVelocity.NormalizedCopy();
            blow.SwingDirection = blow.Direction;
            blow.Position = collisionData.CollisionGlobalPosition;
            blow.BoneIndex = collisionData.CollisionBoneIndex;
            blow.MissileRecord.IsValid = true;
            blow.MissileRecord.CurrentPosition = missilePosition;
            blow.MissileRecord.StartingPosition = missileStartingPosition;
            blow.MissileRecord.MissileItemKind = collisionData.AffectorWeaponKind;
            blow.MissileRecord.ItemFlags = missile.Weapon.PrimaryItem.ItemFlags;
            blow.MissileRecord.WeaponFlags = missile.Weapon.CurrentUsageItem.WeaponFlags;
            blow.MissileRecord.Velocity = collisionData.MissileVelocity;
            blow.StrikeType = (StrikeType)collisionData.StrikeType;
            blow.DamageType = (DamageTypes)collisionData.DamageType;
            blow.VictimBodyPart = collisionData.VictimHitBodyPart;
            blow.WeaponRecord.FillWith(missile.Weapon.CurrentUsageItem, attackerAgent.Monster.GetBoneToAttachForItem(missile.Weapon.PrimaryItem), collisionData.CurrentUsageIndex);
            blow.BaseMagnitude = collisionData.BaseMagnitude;
            blow.MovementSpeedDamageModifier = collisionData.MovementSpeedDamageModifier;
            blow.AbsorbedByArmor = (float)collisionData.AbsorbedByArmor;
            blow.InflictedDamage = collisionData.InflictedDamage;
            blow.SelfInflictedDamage = collisionData.SelfInflictedDamage;
            blow.DamageCalculated = true;
            return blow;
        }


    }

    [HarmonyPatch(typeof(Mission), "DecideAgentHitParticles")]
    class Patch04
    {
        static void Prefix(Agent victim, ref Blow blow, ref object hprd)
        {
            if (victim == Agent.Main)
            {
                blow.WeaponRecord.WeaponFlags |= WeaponFlags.NoBlood;
            }
        }
    }

    //[HarmonyPatch(typeof(Mission), "GetAttackCollisionResults", new Type[]{
    //                            typeof(Agent),typeof(Agent), typeof(GameEntity) , typeof(float), typeof(AttackCollisionData),
    //                            typeof(bool) , typeof(bool) , typeof(WeaponComponentData)
    //                       }, new ArgumentType[] {
    //                            ArgumentType.Normal,ArgumentType.Normal,ArgumentType.Normal,ArgumentType.Normal, ArgumentType.Ref,
    //                            ArgumentType.Normal,ArgumentType.Normal,ArgumentType.Out
    //                       })]
    //class Patch05
    //{
    //    static bool Prefix(Mission __instance, Agent attackerAgent, Agent victimAgent, GameEntity hitObject, float momentumRemaining, ref AttackCollisionData attackCollisionData, bool crushedThrough, bool cancelDamage, out WeaponComponentData shieldOnBack)
    //    {
    //        AttackInformation attackInformation = new AttackInformation(attackerAgent, victimAgent, hitObject, ref attackCollisionData);
    //        shieldOnBack = attackInformation.ShieldOnBack;
    //        CombatLogData combatLogData;
    //        Mission.GetAttackCollisionResults(ref attackInformation, crushedThrough, momentumRemaining, ref attackCollisionData, cancelDamage, out combatLogData);
    //        combatLogData.BodyPartHit = attackCollisionData.VictimHitBodyPart;
    //        combatLogData.IsFatalDamage = (victimAgent != null && victimAgent.Health - (float)attackCollisionData.InflictedDamage <= 0f);
    //        combatLogData.IsVictimEntity = (hitObject != null);
    //        //__instance.PrintAttackCollisionResults(attackerAgent, victimAgent, hitObject, ref attackCollisionData, ref combatLogData, cancelDamage);
    //        return false;
    //    }
    //}

    [HarmonyPatch(typeof(Mission), "AddCombatLogSafe")]
    class Patch06
    {
        static bool Prefix(Mission __instance, Agent attackerAgent, Agent victimAgent, GameEntity hitEntity, CombatLogData combatLog)
        {
            if (victimAgent != Agent.Main)
                return true;

            if (Config.PRINT_HURT)
                return true;
            return false;
        }
    }

    class BattleHelper
    {
        public static string RandomParticleName
        {
            get
            {
                string[] names =
                {
                    "psys_game_metal_metal_coll",
                    "psys_game_metal_stone_coll",
                    //"psys_game_metal_wood_coll",
                    //"psys_game_missile_default_coll",
                    //"psys_game_missile_flame",
                    "psys_game_missile_metal_coll",
                    //"psys_game_missile_mud_coll",
                    //"psys_game_missile_sand_coll",
                    "psys_game_missile_stone_coll",
                    //"psys_game_missile_wood_coll",
                    //"psys_game_merlon_empire_l1",
                    //"psys_game_merlon_empire_l2",
                    //"psys_game_merlon_empire_l3",
                    //"psys_game_hoof_stone_col",
                    //"psys_game_hoof_sand_col",

                };

                int index = MBRandom.RandomInt(names.Length - 1);
                string name = names[index];
                Helper.ShowAndLog($"{name}");
                return name;
            }
        }

    }
}
